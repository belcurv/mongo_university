## Chapter 3: Deeper Dive on the MongoDB Query Language

Query operators: element operators, logical operators, array operators, and the regex operator

For which CRUD operations can one use the query operators we will discuss in this chapter? **ALL of them**.

Given that _upserts_ are a form of create operation, all CRUD operations can make use of a filter. The query operators we are going to discuss in this chapter are used in filters.

#### Comparison Operators

Filter for all movies with a `runtime` greater than 90 minutes.

```
db.movieDetails.find({runtime: {$gt: 90}})
```

For `runtime` greater than 90 minutes and less than 120 minutes:

```
db.movies.find({runtime: { $gt: 90, $lt: 120 }})
```

For `runtime` greater than _or equal to_ 90 minutes and less than _or equal to_ 120 minutes (with projection):

```
db.movieDetails.find({runtime: {$gte: 90, $lte: 120}}, {_id: 0, title: 1, runtime: 1})
```

Mixing things up...

```
db.movieDetails.find({runtime: {$gte: 180}, "tomato.meter": 95}, {_id: 0, title: 1, runtime: 1})
```

Filtering on _not equal_ (`$ne`). Example: finding movies whos rating is anything other than 'UNRATED':

```
db.movieDetails.find({rated: {$ne: "UNRATED"}}, {_id: 0, title: 1, rated: 1})
```

filtering on one or more values, any one of which will cause a document to be returned: `$in`. The value of `$in` must be an array. Select all documents where the value of `rated` is "G" or "PG":

```
db.movieDetails.find({rated: {$in: ["G", "PG"]}}, {_id: 0, title: 1, rated: 1})
```

Extend the filter by adding more elements to the array:

```
db.movieDetails.find({rated: {$in: ["G", "PG", "PG-13"]}}, {_id: 0, title: 1, rated: 1}).pretty()
```

The oppose it `$nin` - _not in_:

```
db.movieDetails.find({rated: {$nin: ["R"]}}, {_id: 0, title: 1, rated: 1}).pretty()
```

#### Element Operators

Test for the existence of a rating:

```
db.moviesDetails.find({mpaaRating: {$exists: true}})
```

Match documents that do NOT contain a `mpaaRating` key:

```
db.moviesDetails.find({mpaaRating: {$exists: false}})
```

Find documents that either have `mpaaRating: null` or do not contain the `mpaaRating` key at all:

```
db.movieDetails.find({mpaaRating: null})
```

Filter for documents that have a particular value type for a field using the `$type` operator. For example, match only document that have a value type for `viewerRating` that is a 32-bit integer:

```
db.movies.find({viewerRating: {$type: "int"}}).pretty()
```

Or look for just doubles instead:

```
db.movies.find({viewerRating: {$type: "double"}}).pretty()
```

#### Logical Operators

Focus on `$or` and `$and`. There's also `$not` and `$nor` operators.

`$or` takes an array in which we specify selectors. Any one of which can be true to match a query.

Example of `$or`. Look for docs based on their rating using both their tomato meter and the metacritic score. We're looking for docs with a tomato.meter greater than 95 and a metacritic score greater than 88:

```
db.movieDetails.find(
  { $or: [
    { "tomato.meter" : { $gt : 95 }},
    { "metacritic"   : { $gt : 88 }}
  ]},
  { _id: 0, title: 1, "tomato.meter": 1, "metacritic": 1}
)
```

`$and` - _both_ conditions must be true. Selectors in a filter are implicitly anded together by default.

```
db.movieDetails.find(
  { $and: [
    { "tomato.meter" : { $gt : 95 }},
    { "metacritic"   : { $gt : 88 }}
  ]},
  { _id : 0, title : 1, "tomato.meter" : 1, "metacritic" : 1}
)
```

... is the same as ...

```
db.movieDetails.find(
  { "tomato.meter" : { $gt : 95 },
    "metacritic"   : { $gt : 88 }
  },
  { _id : 0, title : 1, "tomato.meter" : 1, "metacritic" : 1 }
  )
```

So why is there a `$and` operator? It allows us to apply multiple constraints on the same field. What if we want to check that both `metacritic` exists and it not set to `null`:

```
db.movieDetails.find(
  { $and : [
    { "metacritic" : { $ne     : null }},
    { "metacritic" : { $exists : true }}
  ]},
  { _id : 0, title : 1, "metacritic" : 1 }
)
```

Flip that - find all documents where `metacritic` exists _and_ is set to `null`:

```
db.movieDetails.find(
  { $and : [
    { "metacritic" : null },
    { "metacritic" : { $exists : true }}
  ]},
  { _id: 0, title : 1, "metacritic" : 1 }
)
```

In our class Atlas cluster, ships.shipwrecks collection... `watlev` describes the water level at the shipwreck site and `depth` describes how far below sea level the ship rests. How many documents in the `ships.shipwrecks` collection match either of the following criteria: `watlev` equal to "always dry" or `depth` equal to 0?

```
db.shipwrecks.find(
  {
    $or : [
      { watlev : 'always dry' },
      { depth  : 0 }
    ]
  }
).count()
```

#### Array Operators: $all

$all matches array fields against an array of elements. To match, all the elements we're looking for must be in the array field. Order isn't important.

`$all` takes an array.

```
db.movieDetails.find(
  { genres: { $all: [ "Comedy", "Crime", "Drama" ] } },
  { _id : 0, title : 1, genres : 1}
)
```

In the class Atlas cluster, `100YWeatherSmall.data` collection, The `sections` field in this collection identifies supplementary readings available in a given document by a three-character code. How many documents list: "AG1", "MD1", and "OA1" among the codes in their sections array. Your count should include all documents that include these three codes regardless of what other codes are also listed.

```
db.data
  .find({ sections: { $all: ['AG1', 'MD1', 'OA1'] }})
  .count()
```

#### Array Operators: $size

Use `$size` to match documents based on the length of an array. For example, the `countries` field lists all the countries a movie was filmed in. To find films that were filmed in just one country, we look for `counties` of size = 1:

```
db.movieDetails
  .find({ countries : { $size : 1 } })
```

#### Array Operators: $elemMatch

```
boxOffice: [ { "country": "USA", "revenue": 228.4 },
             { "country": "Australia", "revenue": 19.6 },
             { "country": "UK", "revenue": 33.9 },
             { "country": "Germany", "revenue": 16.2 },
             { "country": "France", "revenue": 19.8 } ]

db.movieDetails.find({"boxOffice.country": "Germany", "boxOffice.revenue": {$gt: 17}})

db.movieDetails.find({"boxOffice.country": "Germany", "boxOffice.revenue": {$gt: 228}})

use video
martian = db.movieDetails.findOne({title: "The Martian"})
martian
delete martian._id;
martian
martian.boxOffice = [
    {"country": "USA", "revenue": 228.4},
    {"country": "Australia", "revenue": 19.6},
    {"country": "UK", "revenue": 33.9},
    {"country": "Germany", "revenue": 16.2},
    {"country": "France", "revenue": 19.8}
]
db.movieDetails.insertOne(martian);

db.movieDetails.find({boxOffice: {$elemMatch: {"country": "Germany", "revenue": {$gt: 17}}}})

db.movieDetails.find({boxOffice: {$elemMatch: {"country": "Germany", "revenue": {$gt: 16}}}})
```

The M001 class Atlas cluster has a database called results. Within this database you will find two collections: `surveys` and `scores`. Documents in the `results.surveys` collection have the following schema.

```
{_id: ObjectId("5964e8e5f0df64e7bc2d7373"),
  results: [
    { product: "abc", score: 10 },
    { product: "xyz", score: 9 }
  ]
}
```

The field called `results` that has an array as its value. This array contains survey results for products and lists the product name and the survey score for each product.

How many documents in the `results.surveys` collection contain a score of 7 for the product, "abc"?

```
db.surveys.find({ results: { $elemMatch : {'score': 7, 'product': 'abc' } } }).count()
```

#### Regex Operator
